{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;GAEG;;AAEH,+BAAgC;AAChC,yDAA0D;AAC1D,0DAA0D;AAE1D,MAAM,QAAQ,GAAG,IAAI,CAAC;AAyBtB,SAAgB,YAAY,CAAC,IAAI,EAAE,KAAM,EAAE,OAAQ;IAElD,IAAI,OAAO,KAAK,IAAI,QAAQ,EAC5B;QACC,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;KACpC;IAED,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;IAExB,IAAI,MAAM,GAAG,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAE/C,IAAI,OAAO,CAAC,YAAY,EACxB;QACC,OAAO,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;KAC3C;IAED,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,KAAK,IAAI,GAAG,CAAC,CAAC;AACzC,CAAC;AAjBD,oCAiBC;AAED,SAAgB,kBAAkB,CAAC,IAAI,EAAE,UAAoB,EAAE;IAE9D,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,UAAU,IAAI;QAElD,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC,CAAC;IAEF,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,UAAU,KAAK,EAAE,GAAG,EAAE,IAAI;QAEpE,iDAAiD;QACjD,OAAO,CAAC,GAAG,KAAK,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IAEF,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,SAAS,CAAC;IAE3D,MAAM,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC;IAEzB,SAAS,UAAU,CAAC,IAAI,EAAE,GAAI,EAAE,IAAc;QAE7C,IAAI,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,EAC1C,SAAS,GAAG,EAAE,EACd,UAAU,GAAG,EAAE,EACf,GAAG,GAAG,KAAK,CAAC,CAAC,4BAA4B;QAE1C,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI;YAE1B,IAAI,WAAW,EAAE,MAAM,CAAC;YAExB,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,EAC9C;gBACC,GAAG,GAAG,IAAI,CAAC;gBACX,OAAO;aACP;YAED,WAAW;gBACV,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;YAE1D,sDAAsD;YACtD,uDAAuD;YACvD,wBAAwB;YACxB,MAAM,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;gBACpD,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC7B,MAAM,CAAC,WAAW,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;QAEH,mBAAmB;QAEnB,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YAE5B,OAAO,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;QAEH,OAAO,OAAO,CAAC,aAAa,CAAC,SAAS,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;IAC1D,CAAC;IAED,IAAI,MAAM,GAAG,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IAC/C,OAAO,MAAM,CAAC;AACf,CAAC;AAzDD,gDAyDC;AAED,SAAgB,SAAS,CAAC,SAAS,EAAE,UAAU,EAAE,GAAY;IAG5D,IAAI,qBAAqB,GAAG,UAAU,EAAE;QAEtC,OAAO,EAAE,CAAC,MAAM,KAAK,CAAC,CAAC;IACxB,CAAC,EACD,MAAM,GAAG,EAAE,CAAC;IAEb,gEAAgE;IAChE,4BAA4B;IAC5B,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EACxB;QAEC,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAC1B;YACC,0DAA0D;YAC1D,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC;SACvB;aACI,IAAI,SAAS,CAAC,KAAK,CAAC,qBAAqB,CAAC,EAC/C;YACC,sDAAsD;YACtD,oDAAoD;YACpD,qBAAqB;YACrB,MAAM,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC;SAC3C;aAED;YACC,oDAAoD;YACpD,MAAM,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;SAC9C;KACD;SACI,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAC9B;QACC,MAAM,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;KACxB;IAED,IAAI,GAAG,IAAI,MAAM,EACjB;QAEC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EACvB;YACC,MAAM,IAAI,GAAG,CAAC;SACd;aAED;YACC,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;SAC/B;KACD;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAnDD,8BAmDC;AAED,SAAgB,UAAU,CAAC,MAAc,EAAE,UAAoB,EAAE;IAEhE,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAC7B;QACC,OAAO,MAAM,CAAC;KACd;IAED,IAAI,CAAC,GAAG,MAAM;SACZ,OAAO,CAAC,6CAA6C,EAAE,MAAM,CAAC,CAAC;IAEjE,IAAI,CAAC,OAAO,CAAC,cAAc,EAC3B;QACC,IAAI,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC;YACtB,KAAK,EAAE,IAAI;SAEX,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;QAEzB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAU,CAAC;YAE3C,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;KACH;IAED,OAAO,CAAC,CAAC;AACV,CAAC;AAxBD,gCAwBC;AAED,SAAgB,gBAAgB,CAAC,MAAM;IAEtC,OAAO,CAAC,OAAO,MAAM,KAAK,QAAQ,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC1D,CAAC;AAHD,4CAGC;AAED,kBAAe,YAAY,CAAA","sourcesContent":["/**\n * Created by user on 2018/6/8/008.\n */\n\nimport jsesc = require('jsesc');\nimport naturalCompare = require('string-natural-compare');\n//import { END_WORD } from 'trie-prefix-tree/dist/config';\n\nconst END_WORD = '$$';\n\nexport type IOptions = {\n\tgetKeys?(value, key?, data?, root?: boolean): string[],\n\tisEndpoint?(value, key, trie): boolean,\n\ttoRegexString?(alt_group, char_class, end): string,\n\n\tdisableEscaped?: boolean,\n\n\tjsescOptions?: {\n\t\tes6?: boolean,\n\t\tminimal?: boolean,\n\t}\n};\n\nexport type IOptionsPlus<T = RegExp> = {\n\tcreateRegExp<T>(source: string, flags?): T\n};\n\nexport type IOptionsAll<T = RegExp> = IOptions & IOptionsPlus<T>;\n\nexport function trieToRegExp<T>(data, options: IOptions & IOptionsPlus<T>, flags?: string): T\nexport function trieToRegExp<T>(data, flags?: string, options?: IOptions & IOptionsPlus<T>): T\nexport function trieToRegExp<T = RegExp>(data, options: IOptions): T\nexport function trieToRegExp<T = RegExp>(data, flags?: string, options?: IOptions): T\nexport function trieToRegExp(data, flags?, options?)\n{\n\tif (typeof flags == 'object')\n\t{\n\t\t[flags, options] = [options, flags];\n\t}\n\n\toptions = options || {};\n\n\tlet source = trieToRegExpSource(data, options);\n\n\tif (options.createRegExp)\n\t{\n\t\treturn options.createRegExp(source, flags);\n\t}\n\n\treturn new RegExp(source, flags || 'u');\n}\n\nexport function trieToRegExpSource(data, options: IOptions = {}): string\n{\n\toptions.getKeys = options.getKeys || function (trie)\n\t{\n\t\treturn Object.keys(trie);\n\t};\n\n\toptions.isEndpoint = options.isEndpoint || function (value, key, trie)\n\t{\n\t\t//return (key === END_WORD) && (trie[key] === 1);\n\t\treturn (key === END_WORD);\n\t};\n\n\toptions.toRegexString = options.toRegexString || _to_regex;\n\n\tconst _fn_push = [].push;\n\n\tfunction _walk_trie(trie, key?, root?: boolean)\n\t{\n\t\tlet keys = options.getKeys(trie, key, data),\n\t\t\talt_group = [],\n\t\t\tchar_class = [],\n\t\t\tend = false; // marks the end of a phrase\n\n\t\tkeys.forEach(function (_key)\n\t\t{\n\t\t\tlet walk_result, insert;\n\n\t\t\tif (options.isEndpoint(trie[_key], _key, trie))\n\t\t\t{\n\t\t\t\tend = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twalk_result =\n\t\t\t\t_quotemeta(_key, options) + _walk_trie(trie[_key], _key);\n\n\t\t\t// When we have more than one key, `insert` references\n\t\t\t// the alternative regexp group, otherwise it points to\n\t\t\t// the char class group.\n\t\t\tinsert = (keys.length > 1) ? _fn_push.bind(alt_group)\n\t\t\t\t: _fn_push.bind(char_class);\n\t\t\tinsert(walk_result);\n\t\t});\n\n\t\t//alt_group.sort();\n\n\t\talt_group.sort(function (a, b)\n\t\t{\n\t\t\treturn (b.length - a.length) || naturalCompare(a, b);\n\t\t});\n\n\t\treturn options.toRegexString(alt_group, char_class, end);\n\t}\n\n\tlet result = _walk_trie(data, undefined, true);\n\treturn result;\n}\n\nexport function _to_regex(alt_group, char_class, end: boolean): string\n{\n\n\tlet group_has_one_element = function (el)\n\t\t{\n\t\t\treturn el.length === 1;\n\t\t},\n\t\tresult = \"\";\n\n\t// Once we've finished walking through the tree we need to build\n\t// the regex match groups...\n\tif (alt_group.length > 0)\n\t{\n\n\t\tif (alt_group.length === 1)\n\t\t{\n\t\t\t// Individual elements are merged with the current result.\n\t\t\tresult += alt_group[0];\n\t\t}\n\t\telse if (alt_group.every(group_has_one_element))\n\t\t{\n\t\t\t// When every single array in the alternative group is\n\t\t\t// a single element array, this gets flattened in to\n\t\t\t// a character class.\n\t\t\tresult += ('[' + alt_group.join('') + ']');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Finally, build a non-capturing alternative group.\n\t\t\tresult += ('(?:' + alt_group.join('|') + ')');\n\t\t}\n\t}\n\telse if (char_class.length > 0)\n\t{\n\t\tresult += char_class[0];\n\t}\n\n\tif (end && result)\n\t{\n\n\t\tif (result.length === 1)\n\t\t{\n\t\t\tresult += '?';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = '(?:' + result + ')?';\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function _quotemeta(phrase: string, options: IOptions = {})\n{\n\tif (!_is_phrase_valid(phrase))\n\t{\n\t\treturn phrase;\n\t}\n\n\tlet s = phrase\n\t\t.replace(/([\\t\\n\\f\\r\\\\\\$\\(\\)\\*\\+\\-\\.\\?\\[\\]\\^\\{\\|\\}])/g, '\\\\$1');\n\n\tif (!options.disableEscaped)\n\t{\n\t\tlet jo = Object.assign({\n\t\t\t'es6': true,\n\t\t\t//'minimal': true,\n\t\t}, options.jsescOptions);\n\n\t\ts = s.replace(/[^\\x20-\\x7E]+/ug, function (s)\n\t\t{\n\t\t\treturn jsesc(s, jo);\n\t\t});\n\t}\n\n\treturn s;\n}\n\nexport function _is_phrase_valid(phrase): phrase is string\n{\n\treturn (typeof phrase === 'string' && phrase.length > 0);\n}\n\nexport default trieToRegExp\n"]}