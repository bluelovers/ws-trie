{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;AACA,qCAA8E;AAE9E,qCAA8B;AAC9B,+CAAwC;AACxC,mDAA4C;AAC5C,mCAAoF;AACpF,qCAAgE;AAChE,mCAAwD;AAA/C,6BAAA,SAAS,CAAA;AAAE,4BAAA,QAAQ,CAAA;AAAE,2BAAA,OAAO,CAAA;AACrC,iDAA0C;AAC1C,2DAAoD;AACpD,2CAAoH;AAGpH,MAAM,aAAa,GAAG,gBAAM,CAAC,aAAa,CAAC;AAE9B,QAAA,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;AAatC,MAAa,IAAI;IAShB,YAAY,KAA+B,EAAE,OAAsB,EAAE,GAAG,IAAI;QAE3E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EACzB;YACC,MAAK,CAAC,gBAAQ,CAAC,iBAAiB,EAAE,OAAO,KAAK,CAAC,CAAC,CAAC;SACjD;QAED,MAAM,IAAI,GAAG,IAAI,CAAC;QAElB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;YAC5B,UAAU,EAAE,IAAI;SACA,EAAE,OAAO,CAAC,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAE3C,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EACxB;YACC,IAAI,CAAC,eAAO,CAAC,GAAG,gBAAM,CAAI,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;YAEtC,KAAsB,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBACrC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,GAAG,CAAC;gBAEvB,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC1B,CAAC,CAAC,CAAC;SACH;aAED;YACC,IAAI,CAAC,eAAO,CAAC,GAAG,gBAAM,CAAI,EAAe,EAAE,GAAG,IAAI,CAAC,CAAC;YAEnD,KAAmB,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBAClC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YACnB,CAAC,CAAC,CAAC;SACH;IACF,CAAC;IAED;;OAEG;IACH,IAAI;QAEH,OAAO,IAAI,CAAC,eAAO,CAAC,CAAC;IACtB,CAAC;IAQD,IAAI,CAAC,GAAG;QAEP,IAAI,CAAC,eAAO,CAAC,GAAG,GAAG,CAAC;QAEpB,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;OAEG;IACH,IAAI,CAAC,SAA0B,CAAC;QAE/B,OAAO,eAAK,CAAC,SAAS,CAAC,IAAI,CAAC,eAAO,CAAC,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,IAAY,EAAE,QAAW,IAAI;QAEpC,gBAAQ,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;QAEjC,MAAM,OAAO,GAAG,CAAC,GAAG,MAAM,EAAE,EAAE;YAE7B,aAAa;YACb,OAAO,gBAAM,CAAC,GAAG,MAAM,CAAC,CAAC;QAC1B,CAAC,CAAC;QAEF,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE1B,MAAM,KAAK,GAAG,aAAK,CAAC,GAAG,CAAC,CAAC;QACzB,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,eAAO,CAAC,CAAC,CAAC;QAEhD,IAAI,CAAC,iBAAQ,CAAC,GAAG,IAAI,CAAC,iBAAQ,CAAC,IAAI,EAAE,CAAC;QACtC,IAAI,CAAC,iBAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;QAC7B,IAAI,CAAC,iBAAQ,CAAC,CAAC,gBAAO,CAAC,GAAG,IAAI,CAAC;QAE/B,OAAO,IAAI,CAAC;IACb,CAAC;IAES,IAAI,CAAC,IAAY;QAE1B,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5D,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,IAAY,EAAE,GAAa;QAErC,gBAAQ,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;QAEjC,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAE5D,IAAI,WAAW,EACf;YACC,IAAI,IAAI,GAAG,UAAU,CAAC,iBAAQ,CAAC,CAAC;YAEhC;;;;;;eAMG;YACH,IAAI,CAAC,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,EACxC;gBACC,IAAI,IAAa,CAAC;gBAElB,IAAI,IAAI,IAAI,IAAI,EAChB;oBACC,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB;qBACI,IAAI,IAAI,CAAC,gBAAO,CAAC,IAAI,IAAI,EAC9B;oBACC,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAO,CAAC,CAAC,CAAC;oBAC3B,IAAI,GAAG,IAAI,CAAC;iBACZ;gBAED,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,gBAAO,CAAC,EACjC;oBACC,IAAI,CAAC,gBAAO,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;iBACrC;aACD;iBAED;gBACC,OAAO,UAAU,CAAC,gBAAM,CAAC,QAAQ,CAAC,CAAC;aACnC;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAES,YAAY,CAAC,MAAc;QAEpC,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC5B,OAAO,qBAAW,CAAC,IAAI,CAAC,eAAO,CAAC,EAAE,GAAG,CAAC,CAAC;IACxC,CAAC;IAED;;;OAGG;IACH,QAAQ,CAAC,MAAc;QAEtB,gBAAQ,CAAC,MAAM,EAAE,kBAAkB,CAAC,CAAC;QAErC,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAElD,OAAO,WAAW,CAAC;IACpB,CAAC;IAED;;;OAGG;IACH,SAAS,CAAC,SAAiB,EAAE,MAAM,GAAG,IAAI;QAEzC,gBAAQ,CAAC,SAAS,EAAE,kBAAkB,CAAC,CAAC;QAExC,IAAI,OAAO,MAAM,KAAK,SAAS,EAC/B;YACC,MAAK,CAAC,gBAAQ,CAAC,2BAA2B,EAAE,OAAO,MAAM,CAAC,CAAC,CAAC;SAC5D;QAED,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAC7B;YACC,OAAO,EAAE,CAAC;SACV;QAED,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAEpD,OAAO,uBAAa,CAAC,UAAU,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IACrD,CAAC;IAOD,uBAAuB,CAAC,GAAG,IAAI;QAE9B,IAAI,SAAiB,CAAC;QAEtB,IAAI,IAAI,CAAC,MAAM,EACf;YACC,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YAEpB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAC7B;gBACC,OAAO,EAAE,CAAC;aACV;SACD;aAED;YACC,SAAS,GAAG,EAAE,CAAC;SACf;QAED,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAEpD,OAAO,2BAAiB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACjD,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,SAAiB;QAE5B,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QAE3C,OAAO,QAAQ,CAAC,MAAM,CAAC;IACxB,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,MAAM,GAAG,IAAI;QAExB,IAAI,OAAO,MAAM,KAAK,SAAS,EAC/B;YACC,MAAK,CAAC,gBAAQ,CAAC,2BAA2B,EAAE,OAAO,MAAM,CAAC,CAAC,CAAC;SAC5D;QACD,OAAO,uBAAa,CAAI,IAAI,CAAC,eAAO,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;IACpD,CAAC;IAED;;;OAGG;IACH,OAAO,CAAC,IAAY;QAEnB,IAAI,OAAO,IAAI,KAAK,QAAQ,EAC5B;YACC,MAAK,CAAC,gBAAQ,CAAC,aAAa,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC;SAC5C;QAED,IAAI,IAAI,KAAK,EAAE,EACf;YACC,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,YAAY,CAAE,IAAI,CAAC,CAAC;YAE7D,IAAI,WAAW,EACf;gBACC,aAAa;gBACb,0DAA0D;gBAC1D,OAAO,mBAAW,CAAC,UAAU,CAAC,CAAC;aAC/B;SACD;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAoBD,WAAW,CAAC,IAAY,EAAE,aAAuB;QAEhD,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAElC,IAAI,IAAI,EACR;YACC,IAAI,IAAI,IAAI,IAAI,EAChB;gBACC,OAAO;oBACN,GAAG,EAAE,IAAI;oBACT,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC;oBACjB,OAAO,EAAE,IAAI,KAAK,IAAI;iBACtB,CAAC;aACF;iBACI,IAAI,CAAC,aAAa,IAAI,gBAAO,IAAI,IAAI,EAC1C;gBACC,IAAI,CAAC,GAAW,IAAI,CAAC,gBAAO,CAAC,CAAC;gBAE9B,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,EAChB;oBACC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzB;gBAED,IAAI,CAAC,IAAI,IAAI,EACb;oBACC,OAAO;wBACN,GAAG,EAAE,CAAC;wBACN,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;wBACd,OAAO,EAAE,CAAC,KAAK,IAAI;qBACnB,CAAC;iBACF;aACD;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IASD,WAAW,CAAC,IAAY;QAEvB,IAAI,OAAO,IAAI,KAAK,QAAQ,EAC5B;YACC,MAAK,CAAC,gBAAQ,CAAC,aAAa,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC;SAC5C;QAED,IAAI,IAAI,KAAK,EAAE,EACf;YACC,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,YAAY,CAAE,IAAI,CAAC,CAAC;YAE7D,IAAI,mBAAW,CAAC,UAAU,CAAC,EAC3B;gBACC,OAAO,UAAU,CAAC,iBAAQ,CAAC,CAAC;aAC5B;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,IAAY;QAE3B,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAElC,IAAI,IAAI,EACR;YACC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzB;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAES,UAAU,CAAC,OAAe;QAEnC,IAAI,OAAO,OAAO,KAAK,QAAQ,EAC/B;YACC,MAAK,CAAC,gBAAQ,CAAC,gBAAgB,EAAE,OAAO,OAAO,CAAC,CAAC,CAAC;SAClD;QAED,IAAI,OAAO,CAAC,MAAM,GAAG,aAAa,EAClC;YACC,MAAK,CAAC,gBAAQ,CAAC,YAAY,aAAa,UAAU,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;SACrE;QAED,aAAa;QACb,OAAO,OAAO,CAAA;IACf,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,OAAe;QAE1B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAEzB,OAAO,sBAAY,CAAC,OAAO,EAAE,IAAI,CAAC,eAAO,CAAC,EAAE;YAC3C,IAAI,EAAE,SAAS;SACf,CAAC,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,cAAc,CAAC,OAAe;QAE7B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAEzB,OAAO,sBAAY,CAAC,OAAO,EAAE,IAAI,CAAC,eAAO,CAAC,EAAE;YAC3C,IAAI,EAAE,aAAa;SACnB,CAAC,CAAC;IACJ,CAAC;IAID,QAAQ,CAAI,KAAM,EAAE,OAAQ;QAE3B,IAAI,CAAC,KAAK,IAAI,CAAC,gBAAQ,CAAC,KAAK,CAAC,EAC9B;YACC,KAAK,GAAG,GAAG,CAAC;YAEZ,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,EAC3B;gBACC,KAAK,IAAI,GAAG,CAAC;aACb;SACD;QAED,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;YACvB,cAAc,EAAE,IAAI;YACpB,UAAU,EAAV,kBAAU;YAEV,YAAY,EAAE;gBACb,KAAK,EAAE,IAAI;gBACX,SAAS,EAAE,KAAK;aAChB;SAED,EAAE,OAAO,CAAC,CAAC;QAEZ,OAAO,oBAAY,CAAI,IAAI,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACrD,CAAC;CAED;AAvbD,oBAubC;AAOD,SAAgB,UAAU,CAAuB,GAAG,IAAI;IAEvD,aAAa;IACb,OAAO,IAAI,IAAI,CAAI,GAAG,IAAI,CAAC,CAAC;AAC7B,CAAC;AAJD,gCAIC;AAED,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE;IACzB,SAAS,EAAE,IAAI,CAAC,SAAS;CACzB,CAAC,CAAC;AAEH,wCAAwC;AAExC,kBAAe,UAAU,CAAA","sourcesContent":["\nimport create, { ITrieRaw, ITrieNode, ITrie, ITrieNodeValue } from './create';\nexport { ITrieRaw, ITrieNode, ITrie, ITrieNodeValue } from './create';\nimport append from './append';\nimport checkPrefix from './checkPrefix';\nimport recursePrefix from './recursePrefix';\nimport utils, { hasEndpoint, isEndpoint, isString, split, throwMsg } from './utils';\nimport config, { END_VALUE, END_WORD, END_DEF } from './config';\nexport { END_VALUE, END_WORD, END_DEF } from './config';\nimport permutations from './permutations';\nimport recurseRandomWord from './recurseRandomWord';\nimport trieToRegExp, { IOptionsAll as ITrieToRegExpOptionsAll, IOptions as ITrieToRegExpOptions } from 'trie-regex';\nexport { IOptionsAll as ITrieToRegExpOptionsAll, IOptions as ITrieToRegExpOptions } from 'trie-regex';\n\nconst PERMS_MIN_LEN = config.PERMS_MIN_LEN;\n\nexport const SYM_RAW = Symbol('trie');\n\nexport type IInput<T> = string[];\nexport type IInputMap<T> = [string, T][];\n\nexport type ITrieOptions = {\n\t/**\n\t * @default true\n\t */\n\tignoreCase?: boolean,\n\tmapMode?: boolean,\n}\n\nexport class Trie<T = typeof END_VALUE>\n{\n\t[SYM_RAW]: ITrieRaw<T>;\n\toptions?: Readonly<ITrieOptions>;\n\n\tconstructor(input: IInputMap<T>, options?: ITrieOptions & {\n\t\tmapMode: true,\n\t}, ...argv)\n\tconstructor(input: IInput<T>, options?: ITrieOptions, ...argv)\n\tconstructor(input: IInput<T> | IInputMap<T>, options?: ITrieOptions, ...argv)\n\t{\n\t\tif (!Array.isArray(input))\n\t\t{\n\t\t\tthrow(throwMsg('parameter Array', typeof input));\n\t\t}\n\n\t\tconst self = this;\n\n\t\tthis.options = Object.assign({\n\t\t\tignoreCase: true,\n\t\t} as ITrieOptions, options);\n\t\tthis.options = Object.freeze(this.options);\n\n\t\tif (this.options.mapMode)\n\t\t{\n\t\t\tthis[SYM_RAW] = create<T>([], ...argv);\n\n\t\t\t(input as IInputMap<T>).forEach(row => {\n\t\t\t\tlet [key, value] = row;\n\n\t\t\t\tself.addWord(key, value);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis[SYM_RAW] = create<T>([] as IInput<T>, ...argv);\n\n\t\t\t(input as IInput<T>).forEach(key => {\n\t\t\t\tself.addWord(key);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the generated raw trie object\n\t */\n\ttree()\n\t{\n\t\treturn this[SYM_RAW];\n\t}\n\n\t/**\n\t * Get a string representation of the trie\n\t */\n\tload(obj: ITrieRaw<T>): this\n\tload<R>(obj: ITrieRaw<R>): this\n\tload(obj): this\n\tload(obj)\n\t{\n\t\tthis[SYM_RAW] = obj;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get a string representation of the trie\n\t */\n\tdump(spacer: string | number = 0)\n\t{\n\t\treturn utils.stringify(this[SYM_RAW], spacer);\n\t}\n\n\t/**\n\t * Add a new word to the trie\n\t */\n\taddWord(word: string, value: T = null)\n\t{\n\t\tisString(word, 'word is string');\n\n\t\tconst reducer = (...params) =>\n\t\t{\n\t\t\t// @ts-ignore\n\t\t\treturn append(...params);\n\t\t};\n\n\t\tlet key = this._key(word);\n\n\t\tconst input = split(key);\n\t\tlet node = input.reduce(reducer, this[SYM_RAW]);\n\n\t\tnode[END_WORD] = node[END_WORD] || {};\n\t\tnode[END_WORD][word] = value;\n\t\tnode[END_WORD][END_DEF] = word;\n\n\t\treturn this;\n\t}\n\n\tprotected _key(word: string)\n\t{\n\t\treturn this.options.ignoreCase ? word.toLowerCase() : word;\n\t}\n\n\t/**\n\t * Remove an existing word from the trie\n\t */\n\tremoveWord(word: string, all?: boolean)\n\t{\n\t\tisString(word, 'word is string');\n\n\t\tconst { prefixFound, prefixNode } = this._checkPrefix(word);\n\n\t\tif (prefixFound)\n\t\t{\n\t\t\tlet node = prefixNode[END_WORD];\n\n\t\t\t/**\n\t\t\t * 更改了 removeWord 行為\n\t\t\t * 會先刪除與 word 符合的 key 值\n\t\t\t * 如果沒有則刪除 預設值\n\t\t\t * 基本上這個狀況只會發生在 ignoreCase = true 時\n\t\t\t * 不論如何每次執行都必定刪除一個 key\n\t\t\t */\n\t\t\tif (!all && Object.keys(node).length > 1)\n\t\t\t{\n\t\t\t\tlet bool: boolean;\n\n\t\t\t\tif (word in node)\n\t\t\t\t{\n\t\t\t\t\tdelete node[word];\n\t\t\t\t}\n\t\t\t\telse if (node[END_DEF] in node)\n\t\t\t\t{\n\t\t\t\t\tdelete node[node[END_DEF]];\n\t\t\t\t\tbool = true;\n\t\t\t\t}\n\n\t\t\t\tif (bool || word == node[END_DEF])\n\t\t\t\t{\n\t\t\t\t\tnode[END_DEF] = Object.keys(node)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelete prefixNode[config.END_WORD];\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _checkPrefix(prefix: string)\n\t{\n\t\tlet key = this._key(prefix);\n\t\treturn checkPrefix(this[SYM_RAW], key);\n\t}\n\n\t/**\n\t * Check a prefix is valid\n\t * @returns Boolean\n\t */\n\tisPrefix(prefix: string): prefix is string\n\t{\n\t\tisString(prefix, 'prefix is string');\n\n\t\tconst { prefixFound } = this._checkPrefix(prefix);\n\n\t\treturn prefixFound;\n\t}\n\n\t/**\n\t * Get a list of all words in the trie with the given prefix\n\t * @returns Array\n\t */\n\tgetPrefix(strPrefix: string, sorted = true)\n\t{\n\t\tisString(strPrefix, 'prefix is string');\n\n\t\tif (typeof sorted !== 'boolean')\n\t\t{\n\t\t\tthrow(throwMsg('sort parameter as boolean', typeof sorted));\n\t\t}\n\n\t\tif (!this.isPrefix(strPrefix))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\n\t\tconst { prefixNode } = this._checkPrefix(strPrefix);\n\n\t\treturn recursePrefix(prefixNode, strPrefix, sorted);\n\t}\n\n\t/**\n\t * Get a random word in the trie with the given prefix\n\t * @returns String\n\t */\n\tgetRandomWordWithPrefix(strPrefix?: string): string\n\tgetRandomWordWithPrefix(...argv): string\n\t{\n\t\tlet strPrefix: string;\n\n\t\tif (argv.length)\n\t\t{\n\t\t\tstrPrefix = argv[0];\n\n\t\t\tif (!this.isPrefix(strPrefix))\n\t\t\t{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrPrefix = '';\n\t\t}\n\n\t\tconst { prefixNode } = this._checkPrefix(strPrefix);\n\n\t\treturn recurseRandomWord(prefixNode, strPrefix);\n\t}\n\n\t/**\n\t * Count the number of words with the given prefixSearch\n\t * @returns Number\n\t */\n\tcountPrefix(strPrefix: string)\n\t{\n\t\tconst prefixes = this.getPrefix(strPrefix);\n\n\t\treturn prefixes.length;\n\t}\n\n\t/**\n\t * Get all words in the trie\n\t * @returns Array\n\t */\n\tgetWordsAll(sorted = true)\n\t{\n\t\tif (typeof sorted !== 'boolean')\n\t\t{\n\t\t\tthrow(throwMsg('sort parameter as boolean', typeof sorted));\n\t\t}\n\t\treturn recursePrefix<T>(this[SYM_RAW], '', sorted);\n\t}\n\n\t/**\n\t * Check the existence of a word in the trie\n\t * @returns Boolean\n\t */\n\thasWord(word: string)\n\t{\n\t\tif (typeof word !== 'string')\n\t\t{\n\t\t\tthrow(throwMsg('string word', typeof word));\n\t\t}\n\n\t\tif (word !== '')\n\t\t{\n\t\t\tconst { prefixFound, prefixNode } = this._checkPrefix( word);\n\n\t\t\tif (prefixFound)\n\t\t\t{\n\t\t\t\t// @ts-ignore\n\t\t\t\t//return prefixNode[config.END_WORD] === config.END_VALUE;\n\t\t\t\treturn hasEndpoint(prefixNode);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t *\n\t * @example\n\t * tree.getWordData('object.entries')\n\t * // => { key: 'Object.entries', value: null, matched: false }\n\t * tree.getWordData('Object.entries')\n\t * // { key: 'Object.entries', value: null, matched: true }\n\t */\n\tgetWordData(word: string, notChkDefault?: boolean): {\n\t\tkey: string,\n\t\tvalue: T,\n\t\tmatched: boolean,\n\t}\n\tgetWordData<R>(word: string, notChkDefault?: boolean): {\n\t\tkey: string,\n\t\tvalue: R,\n\t\tmatched: boolean,\n\t}\n\tgetWordData(word: string, notChkDefault?: boolean)\n\t{\n\t\tlet node = this.getWordNode(word);\n\n\t\tif (node)\n\t\t{\n\t\t\tif (word in node)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tkey: word,\n\t\t\t\t\tvalue: node[word],\n\t\t\t\t\tmatched: word === word,\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (!notChkDefault && END_DEF in node)\n\t\t\t{\n\t\t\t\tlet k: string = node[END_DEF];\n\n\t\t\t\tif (!(k in node))\n\t\t\t\t{\n\t\t\t\t\tk = Object.keys(node)[0];\n\t\t\t\t}\n\n\t\t\t\tif (k in node)\n\t\t\t\t{\n\t\t\t\t\treturn {\n\t\t\t\t\t\tkey: k,\n\t\t\t\t\t\tvalue: node[k],\n\t\t\t\t\t\tmatched: k === word,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * @example\n\t * tree.getWordNode('Object.entries')\n\t * // => { 'Object.entries': null, [Symbol(default)]: 'Object.entries' }\n\t */\n\tgetWordNode(word: string): ITrieNodeValue<T>\n\tgetWordNode<R>(word: string): ITrieNodeValue<R>\n\tgetWordNode(word: string): ITrieNodeValue<T>\n\t{\n\t\tif (typeof word !== 'string')\n\t\t{\n\t\t\tthrow(throwMsg('string word', typeof word));\n\t\t}\n\n\t\tif (word !== '')\n\t\t{\n\t\t\tconst { prefixFound, prefixNode } = this._checkPrefix( word);\n\n\t\t\tif (hasEndpoint(prefixNode))\n\t\t\t{\n\t\t\t\treturn prefixNode[END_WORD];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * @example\n\t * tree.getWordNodeKeys('Object.entries')\n\t * // => [ 'Object.entries' ]\n\t */\n\tgetWordNodeKeys(word: string): string[]\n\t{\n\t\tlet node = this.getWordNode(word);\n\n\t\tif (node)\n\t\t{\n\t\t\treturn Object.keys(node);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprotected isAnagrams(letters: string): letters is string\n\t{\n\t\tif (typeof letters !== 'string')\n\t\t{\n\t\t\tthrow(throwMsg('string letters', typeof letters));\n\t\t}\n\n\t\tif (letters.length < PERMS_MIN_LEN)\n\t\t{\n\t\t\tthrow(throwMsg(`at least ${PERMS_MIN_LEN} letters`, letters.length));\n\t\t}\n\n\t\t// @ts-ignore\n\t\treturn letters\n\t}\n\n\t/**\n\t * Get a list of valid anagrams that can be made from the given letters\n\t * @returns Array\n\t */\n\tgetAnagrams(letters: string)\n\t{\n\t\tthis.isAnagrams(letters);\n\n\t\treturn permutations(letters, this[SYM_RAW], {\n\t\t\ttype: 'anagram',\n\t\t});\n\t}\n\n\t/**\n\t * Get a list of all sub-anagrams that can be made from the given letters\n\t * @returns Array\n\t */\n\tgetSubAnagrams(letters: string)\n\t{\n\t\tthis.isAnagrams(letters);\n\n\t\treturn permutations(letters, this[SYM_RAW], {\n\t\t\ttype: 'sub-anagram',\n\t\t});\n\t}\n\n\ttoRegExp<R = RegExp>(flags?: string, options?: ITrieToRegExpOptions): R\n\ttoRegExp<R>(flags?: string, options?: ITrieToRegExpOptionsAll<R>): ReturnType<typeof trieToRegExp>\n\ttoRegExp<R>(flags?, options?)\n\t{\n\t\tif (!flags || !isString(flags))\n\t\t{\n\t\t\tflags = 'u';\n\n\t\t\tif (this.options.ignoreCase)\n\t\t\t{\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t}\n\n\t\toptions = Object.assign({\n\t\t\tdisableEscaped: true,\n\t\t\tisEndpoint,\n\n\t\t\tjsescOptions: {\n\t\t\t\t'es6': true,\n\t\t\t\t'minimal': false,\n\t\t\t},\n\n\t\t}, options);\n\n\t\treturn trieToRegExp<R>(this.tree(), flags, options);\n\t}\n\n}\n\n\nexport function createTrie<T = typeof END_VALUE>(input: IInputMap<T>, options?: ITrieOptions & {\n\tmapMode: true,\n}, ...argv): Trie<T>\nexport function createTrie<T = typeof END_VALUE>(input: IInput<T>, options?: ITrieOptions, ...argv): Trie<T>\nexport function createTrie<T = typeof END_VALUE>(...argv)\n{\n\t// @ts-ignore\n\treturn new Trie<T>(...argv);\n}\n\nObject.assign(createTrie, {\n\tprototype: Trie.prototype,\n});\n\n//createTrie.prototype = Trie.prototype;\n\nexport default createTrie\n"]}